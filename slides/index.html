<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>The Cult of Ferris</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/ferris.css" id="theme">

		<script src="dist/reveal.js"></script>
		<script src="https://unpkg.com/roughjs@latest/bundled/rough.js"></script>
        <script src="https://unpkg.com/rough-notation/lib/rough-notation.iife.js"></script>

		<link rel="stylesheet" href="css/prism.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>The Cult of Ferris</h1>
					Welcome, fellow rustlings
					<img src="images/rustacean-flat-gesture.png"></img>
				</section>

				<section>
					<h2>Purpose of the Course</h2>
					<ul>
						<li class="fragment">To learn Rust</li>
						<li class="fragment">To have fun doing it</li>
						<li class="fragment">To learn about computers and everything related to them</li>
						<li class="fragment">To gain practical skills</li>
					</ul>
				</section>

				<section id="int_why_rust">
					<h2>Why Rust?</h2>
					<ul>
						<li class="fragment">"Performance, Reliability, Productivity"</li>
						<li class="fragment">It has many application areas</li>
						<li class="fragment">It has excellent documentation</li>
						<li class="fragment">It's a modern langauge</li>
						<li class="fragment">It's a popular language</li>
						<li class="fragment" id="int_why_rust_f1"><span id="int_why_rust_a1">It <em>can</em> be learned by a beginner</span></li>
					</ul>
					<script>{
						let a1 = RoughNotation.annotate(document.getElementById("int_why_rust_a1"), { type: "box", padding: [-5, 5] });
						Reveal.on("fragmentshown", event => {
						  switch (event.fragment.id) {
						  	case "int_why_rust_f1":
						  		a1.show();
						  		break;
						  }
						});
						Reveal.on("slidechanged", event => {
							if (event.previousSlide.className == "past" && event.currentSlide.id == "int_why_rust") {
								a1.hide();
							}
						});
				  }</script>
				</section>

				<section>
					<h1>Lesson 1</h1>
				</section>

				<section id="l1_what">
					<h2>What is a Computer?</h2>
					<p class="fragment" id="l1_what_f1">A <span id="l1_what_a1">machine</span></p>
					<p class="fragment" id="l1_what_f2">An <span id="l1_what_a2">information processor</span></p>
					<p class="fragment" id="l1_what_f3">A <span id="l1_what_a3">tool for humans</span></p>
					<script>{
						let a1 = RoughNotation.annotate(document.getElementById("l1_what_a1"), { type: "underline", padding: [-5, 5] });
						let a2 = RoughNotation.annotate(document.getElementById("l1_what_a2"), { type: "underline", padding: [-5, 5] });
						let a3 = RoughNotation.annotate(document.getElementById("l1_what_a3"), { type: "underline", padding: [-5, 5] });
						let a = RoughNotation.annotationGroup([ a1, a2, a3 ]);
						Reveal.on("fragmentshown", event => {
						  switch (event.fragment.id) {
						  	case "l1_what_f1":
						  		a1.show();
						  		break;
								case "l1_what_f2":
									a2.show();
									break;
								case "l1_what_f3":
									a3.show();
									break;
						  }
						});
						Reveal.on("slidechanged", event => {
							if (event.previousSlide.className == "past" && event.currentSlide.id == "l1_what") {
								a.hide();
							}
						});
				  }</script>
				</section>

				<section id="l1_machine">
					<h2>The Computer as a</h2>
					<h2><span id="l1_machine_a1">Machine</span></h2>
					<script>{
						let a1 = RoughNotation.annotate(document.getElementById("l1_machine_a1"), { type: "underline", padding: [-10, 5] });
						Reveal.on("slidechanged", event => {
							if (event.currentSlide.id == "l1_machine") {
								a1.show();
							} else if (event.previousSlide.id == "l1_machine") {
								a1.hide();
							}
						});
				  }</script>
				</section>

				<section id="l1_computer">
					<h2>The Computer System</h2>
					<canvas id="l1_computer_canvas" width="1000" height="500"></canvas>
					<a class="fragment" id="l1_computer_f1"></a>
					<a class="fragment" id="l1_computer_f2"></a>
					<a class="fragment" id="l1_computer_f3"></a>
					<a class="fragment" id="l1_computer_f4"></a>
					<a class="fragment" id="l1_computer_f5"></a>
					<a class="fragment" id="l1_computer_f6"></a>
					<script>{
						let c = document.getElementById("l1_computer_canvas");
						let d = c.getContext('2d');
				    let r = rough.canvas(c);
						d.font = "30px cutiveMono";
						d.textAlign = "center";
						Reveal.on("fragmentshown", event => {
						  switch (event.fragment.id) {
						  	case "l1_computer_f1":
						  		r.rectangle(450, 200, 100, 100, { fill: 'red' });
									d.fillText("Controller", 500, 150);
						  		break;
								case "l1_computer_f2":
									r.rectangle(150, 200, 100, 100, { fill: 'green' });
									d.fillText("Memory", 200, 150);
						  		break;
								case "l1_computer_f3":
									r.rectangle(750, 200, 100, 100, { fill: 'blue' });
									d.fillText("Peripherals", 800, 150);
						  		break;
								case "l1_computer_f4":
									r.line(300, 250, 400, 250, { bowing: 3, strokeWidth: 2 });
									r.line(300, 250, 310, 260, { strokeWidth: 2 });
									r.line(300, 250, 310, 240, { strokeWidth: 2 });
									r.line(400, 250, 390, 260, { strokeWidth: 2 });
									r.line(400, 250, 390, 240, { strokeWidth: 2 });

									r.line(600, 250, 700, 250, { bowing: 3, strokeWidth: 2 });
									r.line(600, 250, 610, 260, { strokeWidth: 2 });
									r.line(600, 250, 610, 240, { strokeWidth: 2 });
									r.line(700, 250, 690, 260, { strokeWidth: 2 });
									r.line(700, 250, 690, 240, { strokeWidth: 2 });
						  		break;
								case "l1_computer_f5":
									d.fillText("CPU", 500, 350);
									d.fillText("Microcontroller", 500, 380);
						  		break;
								case "l1_computer_f6":
									d.fillText("Keyboard", 800, 350);
									d.fillText("Display", 800, 380);
									d.fillText("Toaster", 800, 410);
						  		break;
						  }
						});
						Reveal.on("slidechanged", event => {
							if (event.previousSlide.className == "past" && event.currentSlide.id == "l1_computer") {
								d.clearRect(0, 0, c.width, c.height);
							}
						});
				  }</script>
				</section>

				<section>
					<h2>The Transistor</h2>
					<p class="fragment">Why?</p>
					<ul>
						<li class="fragment">Smaller</li>
						<li class="fragment">Faster</li>
						<li class="fragment">Simpler</li>
					</ul>
				</section>

				<section>
					<img src="images/mosfet.png"></img>
                    <p style="font-size: x-large">Buttay, Cyril, et al. <i>Lateral MOSFET</i>. <a href="https://commons.wikimedia.org/wiki/File:Lateral_mosfet.svg">https://commons.wikimedia.org/wiki/File:Lateral_mosfet.svg</a>.</p>
				</section>

				<section>
					<img src="images/mosfet_electron_density.gif"></img>
                    <p style="font-size: x-large">Mehrotra, Saumitra R and Gerhard Klimeck. <i>Threshold Formation</i>. 26 August 2010, <a href="https://commons.wikimedia.org/wiki/File:Threshold_formation_nowatermark.gif">https://commons.wikimedia.org/wiki/File:Threshold_formation_nowatermark.gif</a>.</p>
				</section>

				<section>
					<h2>Boolean Algebra</h2>
					<p class="fragment">ON or OFF, YES or NO, 1 or 0</p>
					<p class="fragment">Two possible states</p>
					<p class="fragment">All functions can be implemented using just three operations</p>
				</section>

				<section>
					<p style="font-size: larger">And</p>
					<p style="font-size: larger">$\wedge$</p>
					<p style="font-size: larger">(<code>& or &&</code>)</p>
				</section>

				<section>
					<p style="font-size: larger">Or</p>
					<p style="font-size: larger">$\vee$</p>
					<p style="font-size: larger">(<code>| or ||</code>)</p>
				</section>

				<section>
					<p style="font-size: larger">Not</p>
					<p style="font-size: larger">$\neg$</p>
					<p style="font-size: larger">(<code>!</code>)</p>
				</section>

				<section>
					<h2>Boolean Algebra</h2>
					<table>
						<tr>
							<th>$a$</th>
							<th>$b$</th>
							<th>$a\wedge b$</th>
							<th>$a\vee b$</th>
							<th>$\neg a$</th>
						</tr>
						<tr>
							<td style="text-align: center;">0</td>
							<td style="text-align: center;">0</td>
							<td style="text-align: center;">0</td>
							<td style="text-align: center;">0</td>
							<td style="text-align: center;">1</td>
						</tr>
						<tr>
							<td style="text-align: center;">1</td>
							<td style="text-align: center;">0</td>
							<td style="text-align: center;">0</td>
							<td style="text-align: center;">1</td>
							<td style="text-align: center;">0</td>
						</tr>
						<tr>
							<td style="text-align: center;">0</td>
							<td style="text-align: center;">1</td>
							<td style="text-align: center;">0</td>
							<td style="text-align: center;">1</td>
							<td style="text-align: center;"></td>
						</tr>
						<tr>
							<td style="text-align: center;">1</td>
							<td style="text-align: center;">1</td>
							<td style="text-align: center;">1</td>
							<td style="text-align: center;">1</td>
							<td style="text-align: center;"></td>
						</tr>
					</table>
				</section>

				<section>
					<img src="images/basic_gates.gif"></img>
                    <p style="font-size: x-large">Pratt, Vaughan. <i>Logic Gates</i>. 27 January 2008, <a href="https://commons.wikimedia.org/wiki/File:LogicGates.GIF">https://commons.wikimedia.org/wiki/File:LogicGates.GIF</a>.</p>
				</section>

				<section>
					<h2>Secondary Operations</h2>
					<p style="font-size: larger">Exclusive Or</p>
					<p style="font-size: larger">$\oplus$</p>
					<p style="font-size: larger">(<code>^</code>)</p>
					<p style="font-size: larger">$a\oplus b=(\neg a\wedge b)\vee (a\wedge\neg b)$</p>
				</section>

				<section>
					<img src="images/xor.png"></img>
					<p>$a\oplus b=(a\vee b)\wedge \neg(a\vee b)=(\neg a\wedge b)\vee (a\wedge\neg b)$</p>
                    <p style="font-size: x-large">Officer781. <i>3 Gate XOR</i>. 5 August 2019, <a href="https://commons.wikimedia.org/wiki/File:3_gate_XOR.svg">https://commons.wikimedia.org/wiki/File:3_gate_XOR.svg</a>.</p>
				</section>

				<section>
					<h2>Tertiary Operations</h2>
					<p class="fragment">Addition</p>
					<table class="fragment">
						<tr>
							<th>$a$</th>
							<th>$b$</th>
							<th>$a+b$</th>
						</tr>
						<tr>
							<td style="text-align: center;">0</td>
							<td style="text-align: center;">0</td>
							<td class="fragment" style="text-align: center;">0</td>
						</tr>
						<tr>
							<td style="text-align: center;">1</td>
							<td style="text-align: center;">0</td>
							<td class="fragment" style="text-align: center;">1</td>
						</tr>
						<tr>
							<td style="text-align: center;">0</td>
							<td style="text-align: center;">1</td>
							<td class="fragment" style="text-align: center;">1</td>
						</tr>
						<tr>
							<td style="text-align: center;">1</td>
							<td style="text-align: center;">1</td>
							<td class="fragment" style="text-align: center;">10</td>
						</tr>
					</table>
					<p class="fragment">$x_1=a\oplus b, x_2=a\wedge b$</p>
				</section>

				<section>
					<img src="images/half_adder.png"></img>
                    <p style="font-size: x-large">inductiveload. <i>Half Adder</i>. 5 August 2006, <a href="https://commons.wikimedia.org/wiki/File:Half_Adder.svg">https://commons.wikimedia.org/wiki/File:Half_Adder.svg</a>.</p>
				</section>

				<section>
					<h2>Notation</h2>
					<ul>
						<li class="fragment">Decimal <code>42</code> ($x\mod10^n$)</li>
						<li class="fragment">Binary <code>0b00101010</code> ($x\mod2^n$)</li>
						<li class="fragment">Hexadecimal <code>0x2a</code> ($x\mod16^n$)</li>
						<li class="fragment">Octal <code>0o052</code> ($x\mod8^n$)</li>
					</ul>
				</section>

				<section id="l1_information">
					<h2>The Computer as an</h2>
					<h2><span id="l1_information_a1">Information Processor</span></h2>
					<script>{
						let a1 = RoughNotation.annotate(document.getElementById("l1_information_a1"), { type: "underline", padding: [-10, 5] });
						Reveal.on("slidechanged", event => {
							if (event.currentSlide.id == "l1_information") {
								a1.show();
							} else if (event.previousSlide.id == "l1_information") {
								a1.hide();
							}
						});
				  }</script>
				</section>

				<section id="l1_capabilities">
					<h2>What Capabilities must the Computer System have?</h2>
					<canvas id="l1_capabilities_canvas" width="1000" height="500"></canvas>
					<script>{
						let c = document.getElementById("l1_capabilities_canvas");
						let d = c.getContext('2d');
				    let r = rough.canvas(c);
						d.font = "30px cutiveMono";
						d.textAlign = "center";
						Reveal.on("slidechanged", event => {
							if (event.previousSlide.className == "past" && event.currentSlide.id == "l1_capabilities") {
								d.clearRect(0, 0, c.width, c.height);

								r.rectangle(450, 200, 100, 100, { fill: 'red' });
								d.fillText("Controller", 500, 150);

								r.rectangle(150, 200, 100, 100, { fill: 'green' });
								d.fillText("Memory", 200, 150);

								r.rectangle(750, 200, 100, 100, { fill: 'blue' });
								d.fillText("Peripherals", 800, 150);

								r.line(300, 250, 400, 250, { bowing: 3, strokeWidth: 2 });
								r.line(300, 250, 310, 260, { strokeWidth: 2 });
								r.line(300, 250, 310, 240, { strokeWidth: 2 });
								r.line(400, 250, 390, 260, { strokeWidth: 2 });
								r.line(400, 250, 390, 240, { strokeWidth: 2 });

								r.line(600, 250, 700, 250, { bowing: 3, strokeWidth: 2 });
								r.line(600, 250, 610, 260, { strokeWidth: 2 });
								r.line(600, 250, 610, 240, { strokeWidth: 2 });
								r.line(700, 250, 690, 260, { strokeWidth: 2 });
								r.line(700, 250, 690, 240, { strokeWidth: 2 });
							}
						});
				  }</script>
				</section>

				<section>
					<h2>Everything is Data</h2>
					<p class="fragment">Or, in Unix-speak: "Everything is a file"</p>
				</section>

				<section id="l1_multi_processor">
					<h2>Extension of the Basic Computer Model</h2>
					<canvas id="l1_multi_processor_canvas" width="1000" height="500"></canvas>
					<a class="fragment" id="l1_multi_processor_f1"></a>
					<a class="fragment" id="l1_multi_processor_f2"></a>
					<script>{
						let c = document.getElementById("l1_multi_processor_canvas");
						let d = c.getContext('2d');
				    let r = rough.canvas(c);
						d.font = "30px cutiveMono";
						d.textAlign = "center";
						Reveal.on("fragmentshown", event => {
						  switch (event.fragment.id) {
						  	case "l1_multi_processor_f1":
									d.clearRect(400, 100, 200, 75);

						  		r.rectangle(450, 50, 100, 100, { fill: 'red' });
									r.rectangle(450, 350, 100, 100, { fill: 'red' });
						  		break;
								case "l1_multi_processor_f2":
									d.clearRect(425, 25, 150, 150);
									d.clearRect(425, 325, 150, 150);

									r.rectangle(450, 350, 100, 100, { fill: 'purple' });
						  		break;
						  }
						});
						Reveal.on("slidechanged", event => {
							if (event.previousSlide.className == "past" && event.currentSlide.id == "l1_multi_processor") {
								d.clearRect(0, 0, c.width, c.height);

								r.rectangle(450, 200, 100, 100, { fill: 'red' });
								d.fillText("Controller", 500, 150);

								r.rectangle(150, 200, 100, 100, { fill: 'green' });
								d.fillText("Memory", 200, 150);

								r.rectangle(750, 200, 100, 100, { fill: 'blue' });
								d.fillText("Peripherals", 800, 150);

								r.line(300, 250, 400, 250, { bowing: 3, strokeWidth: 2 });
								r.line(300, 250, 310, 260, { strokeWidth: 2 });
								r.line(300, 250, 310, 240, { strokeWidth: 2 });
								r.line(400, 250, 390, 260, { strokeWidth: 2 });
								r.line(400, 250, 390, 240, { strokeWidth: 2 });

								r.line(600, 250, 700, 250, { bowing: 3, strokeWidth: 2 });
								r.line(600, 250, 610, 260, { strokeWidth: 2 });
								r.line(600, 250, 610, 240, { strokeWidth: 2 });
								r.line(700, 250, 690, 260, { strokeWidth: 2 });
								r.line(700, 250, 690, 240, { strokeWidth: 2 });
							}
						});
				  }</script>
				</section>

				<section id="l1_tool">
					<h2>The Computer as a</h2>
					<h2><span id="l1_tool_a1">Tool for Humans</span></h2>
					<script>{
						let a1 = RoughNotation.annotate(document.getElementById("l1_tool_a1"), { type: "underline", padding: [-10, 5] });
						Reveal.on("slidechanged", event => {
							if (event.currentSlide.id == "l1_tool") {
								a1.show();
							} else if (event.previousSlide.id == "l1_tool") {
								a1.hide();
							}
						});
				  }</script>
				</section>

				<section>
					<h2>We need a language as a layer of abstraction to communicate effectively with these information processors</h2>
				</section>

				<section>
					<h2>The three Ideologies of Programming</h2>
					<p class="fragment">Imperative</p>
					<p class="fragment">Object-Oriented</p>
					<p class="fragment">Functional</p>
				</section>

				<section>
					<h2>The two Translator Personalities of Programming</h2>
					<p class="fragment">Interpreted</p>
					<p class="fragment">Compiled</p>
				</section>

				<section id="l1_translator">
					<h2>The two Translator Personalities of Programming</h2>
					<canvas id="l1_translator_canvas" width="1000" height="500"></canvas>
					<a class="fragment" id="l1_translator_f1"></a>
					<a class="fragment" id="l1_translator_f2"></a>
					<script>{
						let c = document.getElementById("l1_translator_canvas");
						let d = c.getContext('2d');
				    let r = rough.canvas(c);
						d.font = "30px cutiveMono";
						d.textAlign = "center";
						Reveal.on("fragmentshown", event => {
						  switch (event.fragment.id) {
						  	case "l1_translator_f1":
									d.clearRect(175, 200, 600, 100);

									r.ellipse(475, 100, 100, 100, { fill: 'green' });
									d.fillText("Interpreter", 475, 25);

									r.line(200, 200, 375, 100, { bowing: 3, strokeWidth: 2 });
									r.line(375, 100, 375, 115, { strokeWidth: 2 });
									r.line(375, 100, 360, 100, { strokeWidth: 2 });

									r.line(575, 100, 750, 200, { bowing: 3, strokeWidth: 2 });
									r.line(750, 200, 750, 185, { strokeWidth: 2 });
									r.line(750, 200, 735, 200, { strokeWidth: 2 });
						  		break;
								case "l1_translator_f2":
									r.ellipse(350, 400, 100, 100, { fill: 'blue' });
									d.fillText("Compiler", 350, 325);
									r.rectangle(550, 350, 100, 100, { fill: 'blue' });
									d.fillText("Machine Code", 600, 325);

									r.line(450, 400, 500, 400, { bowing: 3, strokeWidth: 2 });
									r.line(500, 400, 490, 410, { strokeWidth: 2 });
									r.line(500, 400, 490, 390, { strokeWidth: 2 });

									r.line(200, 300, 250, 400, { bowing: 3, strokeWidth: 2 });
									r.line(250, 400, 250, 385, { strokeWidth: 2 });
									r.line(250, 400, 235, 400, { strokeWidth: 2 });

									r.line(700, 400, 750, 300, { bowing: 3, strokeWidth: 2 });
									r.line(750, 300, 750, 315, { strokeWidth: 2 });
									r.line(750, 300, 735, 300, { strokeWidth: 2 });
						  		break;
						  }
						});
						Reveal.on("slidechanged", event => {
							if (event.previousSlide.className == "past" && event.currentSlide.id == "l1_translator") {
								d.clearRect(0, 0, c.width, c.height);

								r.rectangle(50, 200, 100, 100, { fill: 'red' });
								d.fillText("Source", 100, 175);
								r.ellipse(850, 250, 100, 100, { fill: 'purple' });
								d.fillText("Computer", 850, 175);

								r.line(200, 250, 750, 250, { bowing: 3, strokeWidth: 2 });
								r.line(750, 250, 740, 260, { strokeWidth: 2 });
								r.line(750, 250, 740, 240, { strokeWidth: 2 });
							}
						});
				  }</script>
				</section>

				<section>
					<h2>Summary</h2>
					<ul>
						<li class="fragment">A computer system can be discussed on different levels of abstraction (machine, information processor, tool)</li>
						<li class="fragment">It is necessary to have some understanding of all levels</li>
					</ul>
				</section>

				<section>
					<h2>Summary</h2>
					<ul style="font-size: xx-large">
						<li class="fragment">Any machine that has a controller, memory and peripherals can be considered a computer (von Neumann architecture)</li>
						<li class="fragment">Peripherals provide an interface between the physical world of humans and the information-based world of computers</li>
						<li class="fragment">Computers are generally based on digital electronics revolving around the transistor</li>
						<li class="fragment">Digital signals can be manipulated to create various mathematical constructs (Boolean algebra)</li>
					</ul>
				</section>

				<section>
					<h2>Summary</h2>
					<ul style="font-size: xx-large">
						<li class="fragment">Using the mathematical abilities of digital circuits, it is possible to construct a general-purpose information processor</li>
						<li class="fragment">Memory is necessary to have stateful information processors</li>
						<li class="fragment">The controller must have the means of executing instructions sequentially</li>
						<li class="fragment">The controller must have the means of executing instructions non-sequentially/conditionally (Turing completeness)</li>
						<li class="fragment">Everything a computer does can be abstracted as a transformation of information</li>
					</ul>
				</section>

				<section>
					<h2>Summary</h2>
					<ul>
						<li class="fragment">Large-scale processing of information is useful for humans</li>
						<li class="fragment">There exists a great variety of programming languages based on multiple paradigms (imperative, object-oriented, functional)</li>
						<li class="fragment">Translation of human-readable algorithms to machine-readable instructions is done through compiler or interpreter programs</li>
					</ul>
				</section>

				<section>
					<h2>Post Scriptum: Setting up the Environment for this Course</h2>
					<span class="fragment">
						<p>Text editor: <a href="https://atom.io/">Atom</a>, <a href="https://code.visualstudio.com/">VS Code</a>, vim, etc.</p>
						<p>Rust toolchain: <a href="https://rustup.rs/">rustup</a></p>
					</p>
					<p class="fragment">For Windows users: <a href="https://putty.org/">Putty</a> or a virtual machine with a Linux distribution (For example <a href="https://www.virtualbox.org/">Virtual Box</a> with <a href="https://ubuntu.com/download/desktop">Ubuntu</a>)</p>
				</section>

				<section>
					<h1>Lesson 2</h1>
				</section>

                <section>
                    <h2>Recap</h2>
                    <p class="fragment">Computers are information processing machines</p>
                    <p class="fragment">We need an intermediate language to interact with these information processors</p>
                </section>

                <section>
                    <h2>The Basics (Slightly Rusty)</h2>
                </section>

                <section>
                    <h2>The Anatomy of a Rust Project</h2>
                    <ul>
                        <li><code>Cargo.toml</code></li>
                        <li><code>Cargo.lock</code></li>
                        <li><code>src</code><ul>
                            <li><code>main.rs</code></li>
                            <li><code>...</code></li>
                        </ul></li>
                        <li><code>target</code><ul>
                            <li><code>...</code></li>
                        </ul></li>
                    </ul>
                </section>

                <section>
                    <h2>The Anatomy of a Rust Project</h2>
                    <p><code>main.rs</code></p>
                    <pre><code class="language-rust">
                        fn main() {
                            println!("Hello, world!");
                        }
                    </code></pre>
                </section>

                <section>
                    <h2>Condition 1: Peripherals</h2>
                </section>

                <section>
                    <h2>Learning to Speak</h2>
                    <pre><code class="language-rust">
                        println!("Hello, world!");
                    </code></pre>
                    <p class="fragment">The <code>println!()</code> macro displays text in the terminal</p>
                </section>

                <section>
                    <h2>Condition 2: Memory</h2>
                </section>

                <section>
                    <h2>Variables</h2>
                    <pre><code class="language-rust">
                        let x = 6;
                        println!("x is {}", x);
                    </code></pre>
                    <p class="fragment">Variables are defined using the <code>let</code> keyword</p>
                </section>

                <section>
                    <h2>Changing Memory</h2>
                    <pre><code class="language-rust">
                        let x = 6;
                        println!("x is {}", x);
                        x = 35;
                        println!("x is {}", x);
                    </code></pre>
                    <img class="fragment" src="images/does_not_compile.png" style="width: 10%;"></img>
                </section>

                <section>
                    <h2>On Mutability</h2>
                    <pre><code class="language-rust">
                        let mut x = 6;
                        println!("x is {}", x);
                        x = 35;
                        println!("x is {}", x);
                    </code></pre>
                    <p class="fragment">Variables are declared changeable using the <code>mut</code> keyword</p>
                </section>

                <section>
                    <section>
                        <h2>Types of Data</h2>
                        <pre><code class="language-rust">
                            let x: i32 = 6;
                            println!("x is {}", x);
                            let y: f64 = 3.1415;
                            println!("y is {}", y);
                            let z: &str = "rusty";
                            println!("z is {}", z);
                        </code></pre>
                        <p class="fragment">Rust is a statically-typed language, therefore all types must be known at compile-time. Types are declared using <code>:</code></p>
                    </section>

                    <section>
                        <h2>Aside: The Type Zoo</h2>
                        <table>
                            <tr>
                                <th>Type Name</th>
                                <th>Description</th>
                                <th>Example</th>
                            </tr>
                            <tr>
                                <td><code>i(8, 16, 32, 64)</code></td>
                                <td>Signed integers</td>
                                <td>-256</td>
                            </tr>
                            <tr>
                                <td><code>u(...)</code></td>
                                <td>Unsigned integers</td>
                                <td>1234</td>
                            </tr>
                            <tr>
                                <td><code>f(32, 64)</code></td>
                                <td>Real numbers (floating point)</td>
                                <td>3.141</td>
                            </tr>
                            <tr>
                                <td><code>str / &str</code></td>
                                <td>Strings (text)</td>
                                <td>"Lorem Ipsum"</td>
                            </tr>
                        </table>
                    </section>
                </section>


                <section>
                    <h2>But is it really?</h2>
                    <pre class="fragment"><code class="language-rust">
                        let x = 6;
                        println!("x is {}", x);
                    </code></pre>
                </section>

                <section>
                    <h2>After some Rust Magic...</h2>
                    <pre><code class="language-rust">
                        fn main() {
                            let x = 6;
                            println!("x is {} and its type is {}", x, type_of(&x));
                        }

                        fn type_of&lt;T>(_: &T) -> &'static str {
                            std::any::type_name::&lt;T>()
                        }
                    </code></pre>
                </section>

                <section>
                    <h2>The Compiler Knows</h2>
                    <pre><code class="language-rust">
                        fn main() {
                            let mut x = 6;
                            println!("x is {} and its type is {}", x, type_of(&x));
                            x = "test";
                            println!("x is {} and its type is {}", x, type_of(&x));
                        }

                        fn type_of&lt;T>(_: &T) -> &'static str {
                            std::any::type_name::&lt;T>()
                        }
                    </code></pre>
                    <img class="fragment" src="images/does_not_compile.png" style="width: 10%;"></img>
                </section>

                <section>
                    <h2>The Solution: Shadowing</h2>
                    <pre><code class="language-rust">
                        fn main() {
                            let x = 6;
                            println!("x is {} and its type is {}", x, type_of(&x));
                            let x = "test";
                            println!("x is {} and its type is {}", x, type_of(&x));
                        }

                        fn type_of&lt;T>(_: &T) -> &'static str {
                            std::any::type_name::&lt;T>()
                        }
                    </code></pre>
                    <p class="fragment" style="font-size: smaller;">Variables can be redefined, even with different types. This is called shadowing</p>
                </section>

                <section>
                    <h2>Condition 3: Controller</h2>
                </section>

                <section>
                    <h2>Achieving Turing-Completeness</h2>
                    <pre><code class="language-rust">
                        let x = 6;
                        if x == 6 {
                            println!("x is equal to 6");
                        }
                    </code></pre>
                    <p class="fragment">The <code>if</code> keyword can be used to execute code conditionally</p>
                </section>

                <section>
                    <section>
                        <h2>Other Conditions</h2>
                        <pre><code class="language-rust">
                            let x = 6;
                            if x > 6 {
                                println!("x is greater than 6");
                            }
                            if x &lt; 6 {
                                println!("x is less than 6");
                            }
                            if x >= 6 {
                                println!("x is greater than or equal to 6");
                            }
                            if x &lt;= 6 {
                                println!("x is less than or equal to 6");
                            }
                        </code></pre>
                    </section>

                    <section>
                        <h2>Aside: Boolean Algebra</h2>
                        <p class="fragment">Boolean algebra facilitates the construction of more complex conditionals</p>
                        <p class="fragment">Conditions can be stored using the <code>bool</code> type</p>
                        <p class="fragment">Conditions can be manipulated using <code>&&</code>, <code>||</code> and <code>!</code></p>
                    </section>

                    <section>
                        <h2>Aside: Boolean Algebra</h2>
                        <pre><code class="language-rust">
                            let x = 6;
                            let y = "goodbye";
                            let is_hello: bool = y == "hello";
                            if (2 &lt;= x && x &lt;= 8) || !is_hello {
                                println!("x is between 2 and 8 or y is not hello");
                            }
                        </code></pre>
                    </section>

                    <section>
                        <h2>Aside: Boolean Algebra</h2>
                        <pre><code class="language-rust">
                            let condition: = True;
                            if condition {
                                println!("Yes");
                            } else {
                                println!("No");
                            }
                        </code></pre>
                    </section>

                    <section>
                        <h2>Aside: Boolean Algebra</h2>
                        <pre><code class="language-rust">
                            let x = 6;
                            if x > 6 {
                                println!("x is greater than 6");
                            } else if x &lt; 6 {
                                println!("x is less than 6");
                            } else {
                                println!("x is 6");
                            }
                        </code></pre>
                    </section>
                </section>

                <section>
                    <h2>No Loopholes</h2>
                    <pre><code class="language-rust">
                        loop {
                            println!("I must not tell lies");
                        }
                    </code></pre>
                    <p class="fragment">The <code>loop</code> keyword can be used to execute code repeatedly</p>
                </section>

                <section id="l2_whats_missing">
                    <h2>What's missing?</h2>
                    <p class="fragment">We need an intermediate language to interact with these information processors<br>
                    <span class="fragment" id="l2_whats_missing_f1"><span id="l2_whats_missing_a1">that is easy for humans to understand</span></span></p>
					<script>{
						let a1 = RoughNotation.annotate(document.getElementById("l2_whats_missing_a1"), { type: "underline", padding: [-5, 5] });
						Reveal.on("fragmentshown", event => {
						  switch (event.fragment.id) {
						  	case "l2_whats_missing_f1":
						  		a1.show();
						  		break;
						  }
						});
						Reveal.on("slidechanged", event => {
							if (event.previousSlide.className == "past" && event.currentSlide.id == "l2_whats_missing") {
								a1.hide();
							}
						});
				    }</script>
                </section>

                <section>
                    <h2>Loopy</h2>
                    <pre><code class="language-rust">
                        let mut x = 0;
                        while x &lt;= 10 {
                            println!("x is {}", x);
                            x = x + 1;
                        }
                    </code></pre>
                    <p class="fragment">The <code>loop</code> keyword can be used to execute code repeatedly</p>
                </section>

                <section>
                    <h2>Pattern Matching</h2>
                    <pre><code class="language-rust">
                        let weather = "cloudy";
                        match weather {
                            "cloudy" => println!("It's cloudy today"),
                            "sunny" => println!("It's sunny today"),
                            "rainy" => println!("It's pouring")
                        }
                    </code></pre>
                </section>

                <section>
                    <h2>Functions: Code Reuse and Other Neat Tricks</h2>
                    <pre><code class="language-rust">
                        fn main() {
                            say_hello();
                        }

                        fn say_hello() {
                            println!("Hello!");
                        }
                    </code></pre>
                    <p class="fragment">The <code>fn</code> keyword can be used to define a function</p>
                </section>

                <section>
                    <h2>Arguments for Parameterisation</h2>
                    <pre><code class="language-rust">
                        fn main() {
                            say_hello("Ferris");
                        }

                        fn say_hello(name: &str) {
                            println!("Hello, {}!", name);
                        }
                    </code></pre>
                </section>

                <section>
                    <h2>Showing our Work</h2>
                    <pre><code class="language-rust">
                        fn main() {
                            println!("Minutes: {}", minutes(135));
                        }

                        fn minutes(x: i32) -> i32 {
                            return x % 60;
                        }
                    </code></pre>
                    <p class="fragment">The <code>return</code> keyword can be used to return values from a function</p>
                </section>


                <section>
                    <h2>When Language Fails You</h2>
                    <pre><code class="language-rust">
                        // I am a comment
                        // This function calculates the answer to everything
                        complicated_calculation();
                    </code></pre>
                </section>

                <section>
					<h2>Summary</h2>
					<ul>
						<li class="fragment">There are a infinitely many ways to achieve the same thing in Rust</li>
						<li class="fragment">The shortest is usually the simplest and most understandable</li>
					</ul>
				</section>

                <section>
					<h1>Project 1</h1>
				</section>

                <section>
                    <h2>The Project</h2>
                    <p>Create a text adventure</p>
                </section> 

                <section>
                    <h2>Background</h2>
                    <ul style="font-size: xx-large">
                        <li class="fragment">As with many early video games, text adventures are the result of academic research</li>
                        <li class="fragment">Developed from programs intended to process and understand natural language (early AI)</li>
                        <li class="fragment">The first proper interactive fiction game was Colossal Cave Adventure (1975)</li>
                        <li class="fragment">Text commands are used to interact with a virtual world and feedback is given in text form</li>
                        <li class="fragment">The gameplay is comparable to modern RPG video games or table-top RPGs</li>
                    </ul>
                </section>

                <section>
                    <h2>Inspiration</h2>
                    <p>Interactive fiction games were traditionally set in fantasy worlds, but more modern examples have deviated from this formula<p>
                    <p><em>Notable examples</em>: Zork, Wizard and the Princess, ESC, AI Dungeon</p>
                </section>

                <section>
                    <h2>Getting Input</h2>
                    <pre><code class="language-rust">
                        use std::io::{stdin, stdout, Write};

                        fn main() {
                            print!("> ");
                            stdout().flush().unwrap();
                            let mut input = String::new();
                            stdin().read_line(&mut input).unwrap();
                            input.pop();
                        }
                    </code></pre>
                </section>

                <section>
                    <h2>An Example</h2>
                    <a href="https://cult.undertheprinter.com/e1">Caverns and Crabs</a>
                    <pre class="language-bash command-line" data-user="ferris" data-host="pc" data-output="1-4"><code>
                        > look
                        You appear to be in a dark cave. The rocky walls are not visible, but you can feel them as you stumble around. You remember that you prepared for a situation like this and probably have flashlight in your bag.
                        > use flashlight
                        You fumble for the flashlight and activate it with a click.
                    </code></pre>
                </section>

                <section>
                    <h1>Lesson 3</h1>
                </section>

                <section>
                    <h2>There is no magic</h2>
                    <pre><code class="language-rust">
                        use std::io::{stdin, stdout, Write};

                        fn main() {
                            print!("> ");
                            stdout().flush().unwrap();
                            let mut input = String::new();
                            stdin().read_line(&mut input).unwrap();
                            input.pop();
                        }
                    </code></pre>
                </section>

                <section>
                    <h2>The Type Zoo</h2>
                    <table>
                        <tr>
                            <th>Type Name</th>
                            <th>Description</th>
                            <th>Example</th>
                        </tr>
                        <tr>
                            <td><code>i(8, 16, 32, 64)</code></td>
                            <td>Signed integers</td>
                            <td>-256</td>
                        </tr>
                        <tr>
                            <td><code>u(...)</code></td>
                            <td>Unsigned integers</td>
                            <td>1234</td>
                        </tr>
                        <tr>
                            <td><code>f(32, 64)</code></td>
                            <td>Real numbers (floating point)</td>
                            <td>3.141</td>
                        </tr>
                        <tr>
                            <td><code>str / &str<span class="fragment"> / String</span></code></td>
                            <td>Strings (text)</td>
                            <td>"Lorem Ipsum"</td>
                        </tr>
                     </table>
                </section>

                <section>
                    <h2>To str or not to str</h2>
                    <pre><code class="language-rust">
                        let mut x: String = "Not a str& anymore".to_string();
                    </code></pre>
                </section>

                <section>
                    <h2>Paraphrasing</h2>
                    <pre><code class="language-rust">
                        let mut x: String = "Not a str& anymore".to_string();
                        x.push_str(". We're a String now.");
                        // Add emphasis
                        x.pop();
                        x.push('!');
                        println!("{}", x);
                    </code></pre>
                    <p>Further reading: <a href="https://doc.rust-lang.org/std/string/struct.String.html">std::string::String</a></p>
                </section>

                <section>
                    <h2>Generalising: Vectors</h2>
                    <pre><code class="language-rust">
                        let mut x: Vec&lt;i32> = Vec::new();
                        x.push(-1);
                        x.push(0);
                        x.push(1);
                        println!("{:?}", x);
                    </code></pre>
                    <p>Further reading: <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">std::vec::Vec</a></p>
                </section>

                <section id="l3_pointers">
                    <h2>On Memory</h2>
					<canvas id="l3_pointers_canvas" width="1000" height="500"></canvas>
					<a class="fragment" id="l3_pointers_f1"></a>
					<a class="fragment" id="l3_pointers_f2"></a>
					<script>{
						let c = document.getElementById("l3_pointers_canvas");
						let d = c.getContext('2d');
				        let r = rough.canvas(c);
						d.font = "30px cutiveMono";
						d.textAlign = "center";
						Reveal.on("fragmentshown", event => {
						    switch (event.fragment.id) {
						  	    case "l3_pointers_f1":
                                    r.rectangle(450, 200, 100, 100, { fill: 'red' });
								    d.fillText("Stack", 500, 150);
								    d.fillText("Pointer", 500, 350);
								    d.fillText("Length", 500, 380);
								    d.fillText("Capacity", 500, 410);

								    r.line(300, 250, 400, 250, { bowing: 3, strokeWidth: 2 });
								    r.line(400, 250, 390, 260, { strokeWidth: 2 });
								    r.line(400, 250, 390, 240, { strokeWidth: 2 });
						  		    break;
								case "l3_pointers_f2":
									r.rectangle(750, 200, 100, 100, { fill: 'blue' });
								    d.fillText("Heap", 800, 150);
								    d.fillText("Data", 800, 350);

									r.line(600, 250, 700, 250, { bowing: 3, strokeWidth: 2 });
								    r.line(700, 250, 690, 260, { strokeWidth: 2 });
								    r.line(700, 250, 690, 240, { strokeWidth: 2 });
						  		    break;
						    }
						});
						Reveal.on("slidechanged", event => {
							if (event.previousSlide.className == "past" && event.currentSlide.id == "l3_pointers") {
								d.clearRect(0, 0, c.width, c.height);

                                r.rectangle(150, 200, 100, 100, { fill: 'green' });
								d.fillText("Variable", 200, 150);
							}
						});
				    }</script>
                </section>

                <section id="l3_deeper">
                    <h2>Digging Deeper</h2>
                    <canvas id="l3_deeper_canvas" width="1000" height="500"></canvas>
					<script>{
						let c = document.getElementById("l3_deeper_canvas");
						let d = c.getContext('2d');
				        let r = rough.canvas(c);
						d.font = "30px cutiveMono";
						d.textAlign = "center";
						Reveal.on("slidechanged", event => {
							if (event.previousSlide.className == "past" && event.currentSlide.id == "l3_deeper") {
								d.clearRect(0, 0, c.width, c.height);

                                r.rectangle(150, 100, 100, 100, { fill: 'green' });
								d.fillText("x", 200, 155);
                                r.rectangle(150, 300, 100, 100, { fill: 'green' });
                                d.fillText("y", 200, 355); 

                                r.rectangle(450, 100, 100, 100, { fill: 'red' });
                                r.rectangle(450, 300, 100, 100, { fill: 'red' });
                                d.fillText("Stack", 500, 50);

                                r.line(300, 150, 400, 150, { bowing: 3, strokeWidth: 2 });
                                r.line(400, 150, 390, 160, { strokeWidth: 2 });
                                r.line(400, 150, 390, 140, { strokeWidth: 2 }); 

                                r.line(300, 350, 400, 350, { bowing: 3, strokeWidth: 2 });
                                r.line(400, 350, 390, 360, { strokeWidth: 2 });
                                r.line(400, 350, 390, 340, { strokeWidth: 2 });

                                r.rectangle(750, 200, 100, 100, { fill: 'blue' });
								d.fillText("Heap", 800, 150);

                                r.line(600, 350, 700, 300, { bowing: 3, strokeWidth: 2 });
								r.line(700, 300, 700, 315, { strokeWidth: 2 });
								r.line(700, 300, 685, 300, { strokeWidth: 2 });

                                r.line(600, 150, 700, 200, { bowing: 3, strokeWidth: 2 });
								r.line(700, 200, 700, 185, { strokeWidth: 2 });
								r.line(700, 200, 685, 200, { strokeWidth: 2 });
							}
						});
				    }</script>
                </section>

                <section>
                    <h2>This is where the "Fun" begins</h2>
                    <ul>
                        <li class="fragment">borrowck prevents programmers from creating race conditions</li>
                        <li class="fragment">To facilitate this, Rust uses the concepts of ownership, borrowing, copying/cloning, moving and mutability</li>
                        <li class="fragment">Our intentions related to these must be defined explicitly</li>
                    <ul>
                </section>

                <section>
                    <h2>Why not move?</h2>
                    <pre><code class="language-rust">
                        let x: String = "Some value".to_string();
                        println!("{}", x);
                        let y = x;
                        println!("{}", y);
                        // println!("{}", x);
                    </code></pre>
                </section>

                <section id="l3_move">
                    <h2>Mechanics of Movement</h2>
                    <canvas id="l3_move_canvas" width="1000" height="500"></canvas>
					<a class="fragment" id="l3_move_f1"></a>
					<a class="fragment" id="l3_move_f2"></a>
					<script>{
						let c = document.getElementById("l3_move_canvas");
						let d = c.getContext('2d');
				        let r = rough.canvas(c);
						d.font = "30px cutiveMono";
						d.textAlign = "center";
						Reveal.on("slidechanged", event => {
							if (event.previousSlide.className == "past" && event.currentSlide.id == "l3_move") {
						        d.font = "30px cutiveMono";
								d.clearRect(0, 0, c.width, c.height);

                                r.rectangle(150, 100, 100, 100, { fill: 'green' });
								d.fillText("x", 200, 155);

                                r.rectangle(450, 100, 100, 100, { fill: 'red' });
                                d.fillText("Stack", 500, 50);

                                r.line(300, 150, 400, 150, { bowing: 3, strokeWidth: 2 });
                                r.line(400, 150, 390, 160, { strokeWidth: 2 });
                                r.line(400, 150, 390, 140, { strokeWidth: 2 }); 

                                r.line(600, 150, 700, 200, { bowing: 3, strokeWidth: 2 });
								r.line(700, 200, 700, 185, { strokeWidth: 2 });
								r.line(700, 200, 685, 200, { strokeWidth: 2 });

                                r.rectangle(750, 200, 100, 100, { fill: 'blue' });
								d.fillText("Heap", 800, 150);
							}
						});
                        Reveal.on("fragmentshown", event => {
						    switch (event.fragment.id) {
						  	    case "l3_move_f1":
									r.rectangle(150, 300, 100, 100, { fill: 'green' });
                                    r.rectangle(450, 300, 100, 100, { fill: 'red' });
                                    d.fillText("y", 200, 355);

                                    r.line(300, 350, 400, 350, { bowing: 3, strokeWidth: 2 });
                                    r.line(400, 350, 390, 360, { strokeWidth: 2 });
                                    r.line(400, 350, 390, 340, { strokeWidth: 2 });

                                    r.line(600, 350, 700, 300, { bowing: 3, strokeWidth: 2 });
								    r.line(700, 300, 700, 315, { strokeWidth: 2 });
								    r.line(700, 300, 685, 300, { strokeWidth: 2 });

						  		    break;
                                case "l3_move_f2":
									d.clearRect(290, 130, 120, 50);
									d.clearRect(590, 140, 120, 70);
						            d.font = "20px cutiveMono";
								    d.fillText("Invalidated", 350, 155);
						  		    break;
						    }
						});
				    }</script>
                </section>

                <section>
                    <h2>The Laws of Borrowck: One Borrow</h2>
                    <pre><code class="language-rust">
                        let x: String = "Some value".to_string();
                        let x_borrowed = &x;
                        // Will not work: x_borrowed.push_str(" modified");
                        println!("{}", x_borrowed);
                    </code></pre>
                </section>

                <section>
                    <h2>The Laws of Borrowck: Two Borrows</h2>
                    <pre><code class="language-rust">
                        let x: String = "Some value".to_string();
                        let x_borrowed = &x;
                        println!("{}", x_borrowed);
                        let x_borrowed_again = &x;
                        println!("{}", x_borrowed_again);
                    </code></pre>
                </section>

                <section>
                    <h2>The Laws of Borrowck: Mutable Borrow</h2>
                    <pre><code class="language-rust">
                        let mut x: String = "Some value".to_string();
                        let x_borrowed = &mut x;
                        x_borrowed.push_str(" modified");
                        println!("{}", x_borrowed);
                    </code></pre>
                </section>

                <section>
                    <h2>The Laws of Borrowck: Two Mutable Borrows?</h2>
                    <pre><code class="language-rust">
                        let mut x: String = "Some value".to_string();
                        let x_borrowed = &mut x;
                        println!("{}", x_borrowed);
                        let x_borrowed_again = &mut x;
                        println!("{}", x_borrowed_again);
                    </code></pre>
                </section>

                <section>
                    <h2>The Laws of Borrowck: Mutable and Immutable Borrows?</h2>
                    <pre><code class="language-rust">
                        let mut x: String = "Some value".to_string();
                        let x_borrowed = &x;
                        println!("{}", x_borrowed);
                        let x_borrowed_mut = &mut x;
                        println!("{}", x_borrowed_again);
                    </code></pre>
                </section>

                <section>
                    <h2>Why not clone?</h2>
                    <pre><code class="language-rust">
                        let mut x: String = "Some value".to_string();
                        println!("{}", x);
                        let y = x.clone();
                        x.push_str(" modified");
                        println!("{}", y);
                        println!("{}", x);
                    </code></pre>
                </section>

                <section>
                    <h2>Last, but not least: Copy</h2>
                    <pre><code class="language-rust">
                        let x: i32 = 42;
                        println!("{}", x);
                        let mut y = x;
                        y = y + 27;
                        println!("{}", y);
                        println!("{}", x);
                    </code></pre>
                </section>

                <section>
                    <section>
                        <h2>Applications: Scope</h2>
                        <ul>
                            <li class="fragment">Scope is defined using blocks</li>
                            <li class="fragment">All variables are only valid within their scope</li>
                            <li class="fragment">Memory is freed automatically when the scope of a variable ends (RAII)</li>
                        <ul>
                    </section>

                    <section>
                        <h2>Applications: Scope</h2>
                        <pre><code class="language-rust">
                            {
                                let in_scope: String = "Scope".to_string();
                                println!("{}", in_scope);
                            }

                            // println!("{}", in_scope);
                        </code></pre>
                    </section>

                    <section>
                        <h2>Applications: Scope</h2>
                        <pre><code class="language-rust">
                            let mut x: String = "Hello".to_string();
                            println!("{}", x);

                            {
                                let x_borrowed = &mut x;
                                x_borrowed.push_str(", world");
                                println!("{}", x_borrowed);
                            }

                            // println!("{}", x_borrowed); &lt;- This will not work!

                            {
                                let x_borrowed_again = &mut x;
                                x_borrowed_again.push_str("!");
                                println!("{}", x_borrowed_again);
                            }

                            println!("{}", x);
                        </code></pre>
                    </section>

                    <section>
                        <h2>Applications: Scope</h2>
                        <pre><code class="language-rust">
                            let outside_scope: &str;

                            {
                                let in_scope: String = "Scope".to_string();
                                outside_scope = &in_scope;
                            }

                            println!("{}", outside_scope);
                        </code></pre>
                    </section>
                </section>

                <section>
                    <h2>Applications: Functions</h2>
                    <pre><code class="language-rust">
                        fn algo(change_this: &mut String, using_this: &str) {
                            change_this.push_str(using_this);
                            change_this.push_str(". And again: ");
                            change_this.push_str(using_this);
                        }
                    </code></pre>
                </section>

                <section>
                    <h2>Just sufficiently advanced technology</h2>
                    <pre><code class="language-rust">
                        use std::io::{stdin, stdout, Write};

                        fn main() {
                            print!("> ");
                            stdout().flush().unwrap();
                            let mut input = String::new();
                            stdin().read_line(&mut input).unwrap();
                            input.pop();
                        }
                    </code></pre>
                </section>

                <section>
                    <h1>Lesson 4</h1>
                </section>

                <section>
                    <h2>Structs</h2>
                    <pre><code class="language-rust">
                        struct Player {
                            name: String,
                            location: i32,
                            hunger: u8,
                            score: u64
                        }

                        fn main() {
                            // Uses Player
                        }
                    </code></pre>
                </section>

                <section>
                    <h2>Instantiating Structs</h2>
                    <pre><code class="language-rust">
                        let player_one = Player {
                            name: "Lloydb".to_string(),
                            location: 0,
                            hunger: 100,
                            score: 0
                        };
                    </code></pre>
                </section>

                <section>
                    <h2>Using Structs</h2>
                    <pre><code class="language-rust">
                        let mut player_one = ...;
                        player_one.score = player_one.score + 100; // player_one.score += 100;
                        player_one.location = 10;
                        println!("{}", player_one.score);
                    </code></pre>
                </section>

                <section>
                    <h2>"Moving" Structs</h2>
                    <p class="fragment">The laws of borrowing apply</p>
                    <pre class="fragment"><code class="language-rust">
                        fn main() {
                            let mut player_one = ...;
                            move_player(&mut player_one, 20);
                            println!("{}", player_one.hunger);
                        }

                        fn move_player(player: &mut Player, destination: i32) {
                            player.hunger -= (destination - player.location).abs() as u8;
                            player.location = destination;
                        }
                    </code></pre>
                </section>

                <section>
                    <h2>Moving Structs</h2>
                    <pre><code class="language-rust">
                        fn main() {
                            let player_one = ...;
                            eat_player(player_one);
                            // println("{}", player_one.name); - The player is no more
                        }

                        fn eat_player(player: Player) {
                            println!("Consuming {}", player.name);
                        }
                    </code></pre>
                </section> 

                <section>
                    <h2>Debugging Structs</h2>
                    <pre><code class="language-rust">
                        #[derive(Debug)]
                        struct Player {
                            ...
                        }

                        fn main() {
                            let player_one = ...;
                            // println!("{}", player_one);
                            println!("{:#?}", player_one);
                        }
                    </code></pre>
                </section>

                <section>
                    <h2>Enumerations</h2>
                    <pre><code class="language-rust">
                        enum Location {
                            CaveOfFerris,
                            MysticalForrest,
                            RustlingVillage,
                            CrustaceanSwamp
                        }
                    </code></pre>
                </section>

                <section>
                    <h2>Enumerations</h2>
                    <pre><code class="language-rust">
                        #[derive(Debug)]
                        enum Location {
                            CaveOfFerris,
                            MysticalForrest,
                            RustlingVillage,
                            CrustaceanSwamp
                        }
                    </code></pre>
                </section>

                <section>
                    <h2>Matchmaking</h2>
                    <pre><code class="language-rust">
                        let location = Location::CaveOfFerris;
                        match location {
                            Location::RustlingVillage | Location::CaveOfFerris => println!("You feel safe."),
                            _ => println!("You feel like you are being watched...")
                        }
                    </code></pre>
                </section>

                <section>
                    <h2>The power of types - You're a wizard, Harry!</h2>
                    <pre><code class="language-rust">
                        enum Item {
                            Wallet(f32),
                            Compass,
                            MysteriousGadget(GadgetItem),
                            Sword(u32)
                        }

                        struct GadgetItem {
                            uses: u32,
                            hidden_feature: bool,
                            owner: String
                        }
                    </code></pre>
                </section>

                <section>
                    <h2>Polymorphism</h2>
                    <pre><code class="language-rust">
                        let item = Item::Wallet(63.50);
                        match item {
                            Item::Wallet(capital) => println!("You have a wallet with ${}", capital),
                            Item::Compass => println!("You have a compass"),
                            Item::MysteriousGadget(gadget) => println!("You have some sort of ancient gadget. A label on it reads {}", gadget.owner),
                            Item::Sword(durability) => {
                                if durability < 50 {
                                    println!("You have a nearly broken sword");
                                } else {
                                    println!("You have a sword");
                                } 
                            }
                        }
                    </code></pre>
                </section>

                <section>
                    <h2>Bonus Data: HashMaps</h2>
                    <pre><code class="language-rust">
                        use std::collections::HashMap;

                        fn main() {
                            let mut sindarin_dictionary: HashMap&lt;String, String> = HashMap::new();
                            sindarin_dictionary.insert("air".to_string(), "gwilith".to_string());
                            sindarin_dictionary.insert("tree".to_string(), "nimloth".to_string());
                            sindarin_dictionary.insert("world".to_string(), "ambar".to_string());
                            println!("\'{}\' in elvish is \'{}\'", "tree", sindarin_dictionary["tree"]);
                        }
                    </code></pre>
                </section>

                <section>
                    <h1>Lesson 5</h1>
                </section>

                <section>
                    <h2>Imagine actually writing real programs in Rust...</h2>
                    <ul>
                        <li>Software can get quite big quite fast (as you probably already experienced)</li>
                        <li>Splitting the project into logical sections will increase maintainability (along with a bunch of other nice bonuses)</li>
                    </ul>
                </section>

                <section>
                    <h2>The organisational tools of Rust</h2>
                    <ul>
                        <li>Packages - Projects</li>
                        <li>Crates - Libraries</li>
                        <li>Modules - Groupings</li>
                    <ul>
                </section>

                <section>
					<h2>Setting up the Environment for this Course</h2>
					<span class="fragment">
						<p>Text editor: <a href="https://atom.io/">Atom</a>, <a href="https://code.visualstudio.com/">VS Code</a>, vim, etc.</p>
						<p>Rust toolchain: <a href="https://rustup.rs/">rustup</a></p>
					</p>
				</section>

                <section>
                    <h2>The anatomy of a Rust project</h2>
                    <ul>
                        <li><code>Cargo.toml</code></li>
                        <li><code>Cargo.lock</code></li>
                        <li><code>src</code><ul>
                            <li><code>main.rs</code> (\/)</li>
                            <li><code>...</code></li>
                        </ul></li>
                        <li><code>target</code><ul>
                            <li><code>debug</code><ul>
                                <li><code>cool_package</code> (binary crate)</li>
                                <li><code>...</code></li>
                            </ul></li>
                        </ul></li>
                    </ul>
                </section>

                <section>
                    <h2>Fix your sarcasm module</h2>
                    <pre><code class="language-rust">
                        mod sarcasm {
                            pub fn programmer() {
                                println!("I absoultely love C++ template metaprogramming");
                            }
                        }

                        fn main() {
                            sarcasm::programmer();
                        }
                    </code></pre>
                </section>

                <section>
                    <h2>Paths are like... paths</h2>
                    <ul>
                        <li><code>src</code><ul>
                            <li><code>main.rs</code></li>
                            <li><code>sarcasm.rs (mod sarcasm { ... })</code></li>
                            <li><code>...</code></li>
                        </ul></li>
                    </ul>
                </section>

                <section>
                    <h2>sarcasm.rs</h2>
                    <pre><code class="language-rust">
                        pub fn programmer() {
                            println!("I absoultely love C++ template metaprogramming");
                        }
                    </code></pre>
                </section>

                <section>
                    <h2>main.rs</h2>
                    <pre><code class="language-rust">
                        mod sarcasm;
                        use sarcasm::programmer;

                        fn main() {
                            programmer();
                        }
                    </code></pre>
                </section>

                <section>
                    <h2>Modules in modules (in crates)</h2>
                    <ul>
                        <li><code>src</code><ul>
                            <li><code>main.rs</code> (main crate \/)</li>
                            <li><code>sarcasm.rs</code> (sarcasm crate \/)</li>
                            <li><code>sarcasm</code><ul>
                                <li><code>political.rs</code></li>
                                <li><code>...</code></li>
                            </ul></li>
                            <li><code>...</code></li>
                        </ul></li>
                    </ul>
                </section>

                <section>
                    <h2>sarcasm.rs</h2>
                    <pre><code class="language-rust">
                        pub mod political;

                        pub fn programmer() {
                            println!("I absoultely love C++ template metaprogramming");
                        }
                    </code></pre>
                </section>

                <section>
                    <h2>main.rs</h2>
                    <pre><code class="language-rust">
                        mod sarcasm;
                        use sarcasm::programmer;
                        use sarcasm::political::*;

                        fn main() {
                            programmer();
                            alternative_facts();
                        }
                    </code></pre>
                </section>

                <section>
                    <h2>Great artists steal (or use crates.io)</h2>
                    <pre><code class="language-rust">
                        [package]
                        name = "caverns-and-crabs"
                        version = "0.1.0"
                        authors = ["TechnoElf &lt;technoelf@undertheprinter.com>"]
                        edition = "2018"

                        [dependencies]
                        rand = "0.7.3"
                    </code></pre>
                </section>

                <section>
                    <h2>Randy random</h2>
                    <pre><code class="language-rust">
                        use rand::random;

                        fn main() {
                            println!("Printing 10 random numbers...");
                            for i in 0..10 {
                                let random_int: i32 = random();
                                println!("{}: {}", i, random_int);
                            }
                        }
                    </code></pre>
                </section>

                <section>
                    <h2>Bonus Data: Error (not) handling</h2>
                    <pre><code class="language-rust">
                        use rand::random;

                        fn main() {
                            for i in 0..10 {
                                let random_int: u8 = random();
                                if i > 100 {
                                    panic!("AAAAAHHHHHHH");
                                }
                            }
                        }
                    </code></pre>
                </section>

                <section>
                    <h1>Lesson 6</h1>
                </section>

                <section>
                    <h2>Option</h2>
                </section>

                <section>
                    <h2>Matching against an Option</h2>
                </section>

                <section>
                    <h2>if let</h2>
                </section>

                <section>
                    <h1>Bibliography</h1>
                    <div style="font-size: xx-large">
                        <p><i>Interactive fiction</i>. Wikipedia, 5 July 2020, <a href="https://en.wikipedia.org/wiki/Interactive_fiction">https://en.wikipedia.org/wiki/Interactive_fiction</a>.</p>
                        <p>Klabnik, Steve and Carol Nichols. <i>The Rust Programming Language</i>. <a href="https://doc.rust-lang.org/stable/book/">https://doc.rust-lang.org/stable/book/</a>.</p>
                        <p>Monk, J Donald. <i>The Mathematics of Boolean Algebra</i>. 11 July 2018, <a href="https://plato.stanford.edu/entries/boolalg-math/">https://plato.stanford.edu/entries/boolalg-math/</a>.</p>
                        <p><i>Rust by Example</i>. <a href="https://doc.rust-lang.org/stable/rust-by-example/">https://doc.rust-lang.org/stable/rust-by-example/</a>.</p>
                        <p>Wolf, Marilyn. <i>Computers as Components</i>. Morgan Kaufmann, 2017.</p>
                    </div>
                </section>
			</div>
		</div>

		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/math/math.js"></script>
		<script>
			Reveal.initialize({
				hash: true,
				plugins: [ RevealNotes, RevealMath ]
			});
		</script>

		<script src="js/prism.js"></script>
	</body>
</html>
